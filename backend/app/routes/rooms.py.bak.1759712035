from typing import List
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from app.db import get_db
from app.deps import get_current_user
from app.models.user import User
from app.models.room import Room, RoomParticipant, Turn
from app.schemas.room import (
    RoomCreate,
    RoomResponse,
    IntakeRequest,
    IntakeResponse,
    TurnResponse,
    TurnFeedItem,
)

router = APIRouter(prefix="/rooms", tags=["rooms"])

# ---- Helpers ----
def extract_tags(text: str) -> List[str]:
    t = (text or "").lower()
    # Safety screening: reject harmful content
    banned = ["violence", "self-harm", "threat"]
    if any(word in t for word in banned):
        # We raise in submit_intake to include correct HTTP status
        pass
    tags: List[str] = []
    if any(w in t for w in ["actually","fact","happened","did","was"]):
        tags.append("fact")
    if any(w in t for w in ["feel","felt","emotion","upset","happy","sad","angry","anxious","tired"]):
        tags.append("feeling")
    if any(w in t for w in ["need","want","would like","could you","please"]):
        tags.append("request")
    if any(w in t for w in ["think","believe","opinion","seems","probably"]):
        tags.append("opinion")
    if not tags:
        tags.append("statement")
    return tags

@router.post("/", response_model=RoomResponse, status_code=status.HTTP_201_CREATED)
def create_room(
    room_data: RoomCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    room = Room(title=room_data.title)
    db.add(room)
    db.flush()  # get room.id

    participant = RoomParticipant(room_id=room.id, user_id=current_user.id, role="creator")
    db.add(participant)
    db.commit()
    db.refresh(room)
    return room

@router.post("/{room_id}/join")
def join_room(
    room_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    room = db.query(Room).filter(Room.id == room_id).first()
    if not room:
        raise HTTPException(status_code=404, detail="Room not found")

    existing = db.query(RoomParticipant).filter(
        RoomParticipant.room_id == room_id,
        RoomParticipant.user_id == current_user.id,
    ).first()

    if existing:
        return {"message": "Already a participant"}

    db.add(RoomParticipant(room_id=room_id, user_id=current_user.id, role="partner"))
    db.commit()
    return {"message": "Joined room"}

@router.post("/{room_id}/intake", response_model=IntakeResponse, status_code=status.HTTP_201_CREATED)
def submit_intake(
    room_id: int,
    intake: IntakeRequest,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    # must exist
    room = db.query(Room).filter(Room.id == room_id).first()
    if not room:
        raise HTTPException(status_code=404, detail="Room not found")

    # must be participant
    participant = db.query(RoomParticipant).filter(
        RoomParticipant.room_id == room_id,
        RoomParticipant.user_id == current_user.id,
    ).first()
    if not participant:
        raise HTTPException(status_code=403, detail="You must join the room before submitting intake")

    # accept either summary or text (fallback)
    effective = (intake.summary or intake.text or "").strip()
    if not effective:
        raise HTTPException(status_code=400, detail="Provide 'text' or 'summary'.")

    # Safety screening: reject certain content
    lowered = effective.lower()
    banned_keywords = ["violence", "self-harm", "threat"]
    if any(bad in lowered for bad in banned_keywords):
        raise HTTPException(
            status_code=422,
            detail="Safety screening failed: please remove sensitive content (violence, self-harm, threat).",
        )

    tags = extract_tags(effective)

    turn = Turn(
        room_id=room_id,
        user_id=current_user.id,
        kind="intake",
        summary=effective,
        desired_outcome=intake.desired_outcome or "",
        nonnegotiables=intake.nonnegotiables or "",
        timeline=intake.timeline or "",
        evidence_urls=intake.evidence_urls or [],
        tags=tags,
    )
    db.add(turn)
    db.commit()
    db.refresh(turn)

    # IMPORTANT: map DB summary -> API "text"
    return IntakeResponse(
        turn_id=turn.id,
        room_id=turn.room_id,
        user_id=turn.user_id,
        kind=turn.kind,
        text=turn.summary or "",
        tags=turn.tags or [],
        created_at=turn.created_at,
    )

@router.get("/{room_id}/intake/self", response_model=List[TurnResponse])
def get_own_intake(
    room_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    # must be participant
    participant = db.query(RoomParticipant).filter(
        RoomParticipant.room_id == room_id,
        RoomParticipant.user_id == current_user.id,
    ).first()
    if not participant:
        raise HTTPException(status_code=403, detail="You are not a participant in this room")

    rows = db.query(Turn).filter(
        Turn.room_id == room_id,
        Turn.user_id == current_user.id,
        Turn.kind == "intake",
    ).order_by(Turn.created_at).all()

    # IMPORTANT: map DB summary -> API "text"
    return [
        TurnResponse(
            id=t.id,
            room_id=t.room_id,
            user_id=t.user_id,
            kind=t.kind,
            text=t.summary or "",
            tags=t.tags or [],
            created_at=t.created_at,
        )
        for t in rows
    ]

@router.get("/my", response_model=List[RoomResponse])
def get_my_rooms(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    rows = db.query(Room).join(RoomParticipant, RoomParticipant.room_id == Room.id).filter(
        RoomParticipant.user_id == current_user.id
    ).order_by(Room.created_at).all()
    return rows

@router.get("/{room_id}/feed", response_model=List[TurnFeedItem])
def get_room_feed(
    room_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    # Verify user is a participant
    participant = db.query(RoomParticipant).filter(
        RoomParticipant.room_id == room_id,
        RoomParticipant.user_id == current_user.id,
    ).first()
    if not participant:
        raise HTTPException(status_code=403, detail="You are not a participant in this room")

    # Get all intake turns for this room with user info, newest first
    rows = db.query(Turn, User).join(User, User.id == Turn.user_id).filter(
        Turn.room_id == room_id,
        Turn.kind == "intake"
    ).order_by(Turn.created_at.desc()).all()

    return [
        TurnFeedItem(
            id=turn.id,
            room_id=turn.room_id,
            user_id=turn.user_id,
            author_name=user.name or user.email,
            text=turn.summary or "",
            tags=turn.tags or [],
            created_at=turn.created_at,
        )
        for turn, user in rows
    ]
