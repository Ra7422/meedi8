# MEEDI8 PAYWALL & SUBSCRIPTION IMPLEMENTATION GUIDE

## Table of Contents
1. [Current State Analysis](#current-state-analysis)
2. [Pricing Tiers & Features](#pricing-tiers--features)
3. [Implementation Priority](#implementation-priority)
4. [Database Schema Changes](#database-schema-changes)
5. [Backend Implementation](#backend-implementation)
6. [Frontend Implementation](#frontend-implementation)
7. [Stripe Configuration](#stripe-configuration)
8. [Testing Checklist](#testing-checklist)

---

## Current State Analysis

### ‚úÖ What's Working
- Stripe Checkout integration (monthly/yearly billing)
- Stripe Customer Portal (cancel, update payment)
- Webhook handling (subscription activation, updates, cancellations)
- Voice recording limits (10/month for FREE, unlimited for PLUS/PRO)
- Voice usage counter increments correctly
- Subscription status endpoint
- Feature access checking system
- HTTP 402 Payment Required errors
- Cost tracking for API calls

### ‚ùå What's Missing
1. **Room creation limits** - No enforcement (HIGH PRIORITY)
2. **File upload size limits** - No validation (MEDIUM PRIORITY)
3. **Professional report counter** - No monthly limit tracking (MEDIUM PRIORITY)
4. **Transcript storage limits** - No UI hiding (LOW PRIORITY)
5. **One-time payments** - For extra reports (FUTURE)

---

## Pricing Tiers & Features

### FREE TIER (¬£0/month)
**Limits:**
- ‚úÖ 10 voice recordings per month (resets monthly)
- üî® **1 active room at a time** (can create new rooms after previous ones resolve)
- üî® No file uploads
- üî® 7-day transcript access (soft limit - hide in UI)
- ‚úÖ Text-based mediation
- ‚úÖ Individual coaching with Meedi
- ‚úÖ Basic conversation summary
- ‚úÖ Email support

**Implementation Notes:**
- "1 active room" = rooms in phases: user1_coaching, user1_intake, user2_coaching, user2_lobby, main_room
- Resolved rooms (phase = "resolved") don't count toward limit
- Users can archive/resolve old rooms to start new ones

### PLUS TIER (¬£9.99/month or ¬£99/year)
**Features:**
- ‚úÖ Unlimited voice recordings
- üî® **Unlimited rooms** (no active room limit)
- üî® **File uploads up to 10MB per session**
- üî® 30-day transcript storage
- ‚úÖ Everything in Free
- ‚úÖ Automatic transcription
- ‚úÖ Download basic session summaries
- ‚úÖ Priority email support

### PRO TIER (¬£19.99/month or ¬£199/year)
**Features:**
- ‚úÖ Unlimited voice recordings
- üî® **Unlimited rooms**
- üî® **File uploads up to 50MB per session**
- üî® **3 professional evaluation reports per month** (additional ¬£4.99 each)
- üî® 90-day transcript storage
- ‚úÖ Everything in Plus
- ‚úÖ Meedi AI voice responses (two-way voice)
- ‚úÖ Advanced relationship pattern analytics (future)
- ‚úÖ Priority support (24-hour response)
- ‚úÖ Export to share with therapists

**Legend:**
- ‚úÖ = Already implemented and working
- üî® = Needs implementation (this guide)

---

## Implementation Priority

### Phase 1: Critical Paywalls (Week 1)
1. **Room creation limits** - Blocks FREE users from creating multiple rooms
2. **File upload size validation** - Enforces tier-based size limits
3. **Update Subscription model** - Add room counter fields

### Phase 2: PRO Features (Week 2)
4. **Professional report counter** - Track monthly report usage
5. **Extra report purchase flow** - One-time Stripe payments

### Phase 3: Polish (Week 3)
6. **Transcript storage UI limits** - Hide old transcripts
7. **Admin dashboard** - Subscription analytics
8. **Usage notifications** - Email alerts at 80% limit usage

---

## Database Schema Changes

### Migration 1: Add Room and Report Counters to Subscription

**File:** `backend/migrations/versions/YYYYMMDD_add_usage_counters.py`

```python
"""Add usage counters to subscriptions

Revision ID: <auto-generated>
Revises: <previous-revision>
Create Date: 2025-11-13
"""
from alembic import op
import sqlalchemy as sa

def upgrade():
    # Add room usage tracking
    op.add_column('subscriptions', sa.Column('rooms_created_this_month', sa.Integer(), nullable=False, server_default='0'))
    op.add_column('subscriptions', sa.Column('month_reset_date', sa.DateTime(), nullable=True))

    # Add professional report tracking (PRO tier only)
    op.add_column('subscriptions', sa.Column('reports_generated_this_month', sa.Integer(), nullable=False, server_default='0'))
    op.add_column('subscriptions', sa.Column('reports_limit_per_month', sa.Integer(), nullable=False, server_default='0'))

    # Initialize month_reset_date to start of current month for existing subscriptions
    op.execute("""
        UPDATE subscriptions
        SET month_reset_date = DATE_TRUNC('month', CURRENT_TIMESTAMP)
        WHERE month_reset_date IS NULL
    """)

def downgrade():
    op.drop_column('subscriptions', 'reports_limit_per_month')
    op.drop_column('subscriptions', 'reports_generated_this_month')
    op.drop_column('subscriptions', 'month_reset_date')
    op.drop_column('subscriptions', 'rooms_created_this_month')
```

### Updated Subscription Model

**File:** `backend/app/models/subscription.py`

Add these fields to the `Subscription` class:

```python
# Room usage tracking
rooms_created_this_month = Column(Integer, default=0, nullable=False)
month_reset_date = Column(DateTime, nullable=True)

# Professional report tracking (PRO tier only)
reports_generated_this_month = Column(Integer, default=0, nullable=False)
reports_limit_per_month = Column(Integer, default=0, nullable=False)  # 0 for FREE/PLUS, 3 for PRO
```

---

## Backend Implementation

### 1. Room Creation Limits

**File:** `backend/app/services/subscription_service.py`

Add new functions:

```python
from datetime import datetime
from dateutil.relativedelta import relativedelta

def reset_monthly_counters_if_needed(db: Session, subscription: Subscription) -> None:
    """Reset monthly counters if we've passed the month boundary"""
    if not subscription.month_reset_date:
        subscription.month_reset_date = datetime.utcnow().replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        subscription.rooms_created_this_month = 0
        subscription.voice_conversations_used = 0
        subscription.reports_generated_this_month = 0
        db.commit()
        return

    # Check if we've passed into a new month
    next_reset = subscription.month_reset_date + relativedelta(months=1)
    if datetime.utcnow() >= next_reset:
        subscription.month_reset_date = datetime.utcnow().replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        subscription.rooms_created_this_month = 0
        subscription.voice_conversations_used = 0
        subscription.reports_generated_this_month = 0
        db.commit()

def get_active_rooms_count(db: Session, user_id: int) -> int:
    """Count rooms that are not yet resolved"""
    from app.models.room import Room

    active_phases = ['user1_intake', 'user1_coaching', 'user2_lobby', 'user2_coaching', 'main_room']

    count = db.query(Room).join(Room.participants).filter(
        User.id == user_id,
        Room.phase.in_(active_phases)
    ).count()

    return count

def can_create_room(db: Session, subscription: Subscription, user_id: int) -> dict:
    """Check if user can create a new room based on their subscription tier"""
    reset_monthly_counters_if_needed(db, subscription)

    # FREE tier: Only 1 active room at a time
    if subscription.tier == SubscriptionTier.FREE:
        active_rooms = get_active_rooms_count(db, user_id)
        if active_rooms >= 1:
            return {
                "can_create": False,
                "reason": "FREE_TIER_ACTIVE_ROOM_LIMIT",
                "message": "Free tier users can have 1 active mediation at a time. Please resolve your current mediation before starting a new one, or upgrade to Plus for unlimited rooms.",
                "active_rooms": active_rooms,
                "limit": 1
            }

    # PLUS and PRO: Unlimited rooms
    return {
        "can_create": True,
        "reason": None,
        "message": None
    }

def increment_room_counter(db: Session, subscription: Subscription) -> None:
    """Increment the rooms created counter for this month"""
    reset_monthly_counters_if_needed(db, subscription)
    subscription.rooms_created_this_month += 1
    db.commit()
```

**File:** `backend/app/routes/rooms.py`

Update the room creation endpoint (around line 65):

```python
@router.post("/", response_model=RoomOut)
async def create_room(
    room_data: RoomCreate,
    user: User = Depends(get_current_user),
    subscription: Subscription = Depends(get_current_subscription),
    db: Session = Depends(get_db)
):
    import logging
    logger = logging.getLogger(__name__)
    logger.info(f"Creating room for user {user.id}, tier: {subscription.tier}")

    # CHECK ROOM CREATION LIMIT
    from app.services.subscription_service import can_create_room, increment_room_counter

    room_check = can_create_room(db, subscription, user.id)
    if not room_check["can_create"]:
        raise HTTPException(
            status_code=402,
            detail={
                "error": room_check["reason"],
                "message": room_check["message"],
                "upgrade_url": "/subscription"
            }
        )

    # Create room
    room = Room(
        title=room_data.title,
        category=room_data.category.lower() if room_data.category else None,
        phase="user1_intake"
    )
    db.add(room)
    db.flush()

    # Add user as participant
    room.participants.append(user)

    # Generate invite token
    room.invite_token = secrets.token_urlsafe(32)

    db.commit()
    db.refresh(room)

    # INCREMENT ROOM COUNTER
    increment_room_counter(db, subscription)

    logger.info(f"Room {room.id} created successfully")
    return room
```

### 2. File Upload Size Limits

**File:** `backend/app/services/subscription_service.py`

Add function:

```python
def get_file_upload_limit_mb(subscription: Subscription) -> int:
    """Get max file upload size in MB based on subscription tier"""
    if subscription.tier == SubscriptionTier.FREE:
        return 0  # No file uploads for FREE
    elif subscription.tier == SubscriptionTier.PLUS:
        return 10  # 10MB for PLUS
    elif subscription.tier == SubscriptionTier.PRO:
        return 50  # 50MB for PRO
    return 0

def can_upload_file(subscription: Subscription, file_size_bytes: int) -> dict:
    """Check if user can upload a file of given size"""
    limit_mb = get_file_upload_limit_mb(subscription)

    if limit_mb == 0:
        return {
            "can_upload": False,
            "reason": "FREE_TIER_NO_FILES",
            "message": "File uploads require a Plus or Pro subscription. Upgrade to share documents, images, and evidence with your mediator.",
            "limit_mb": 0
        }

    file_size_mb = file_size_bytes / (1024 * 1024)

    if file_size_mb > limit_mb:
        tier_name = "Plus" if subscription.tier == SubscriptionTier.PLUS else "Pro"
        return {
            "can_upload": False,
            "reason": "FILE_TOO_LARGE",
            "message": f"File size ({file_size_mb:.1f}MB) exceeds your {tier_name} limit of {limit_mb}MB. {'Upgrade to Pro for 50MB uploads.' if subscription.tier == SubscriptionTier.PLUS else 'Please use a smaller file.'}",
            "limit_mb": limit_mb,
            "file_size_mb": file_size_mb
        }

    return {
        "can_upload": True,
        "reason": None,
        "message": None,
        "limit_mb": limit_mb
    }
```

**File:** `backend/app/routes/rooms.py`

Update file upload endpoint (around line 1961):

```python
@router.post("/{room_id}/main-room/upload-file")
async def upload_file_to_main_room(
    room_id: int,
    file: UploadFile = File(...),
    user: User = Depends(get_current_user),
    subscription: Subscription = Depends(get_current_subscription),
    db: Session = Depends(get_db)
):
    import logging
    logger = logging.getLogger(__name__)

    # Verify room exists and user is participant
    room = db.query(Room).filter(Room.id == room_id).first()
    if not room:
        raise HTTPException(status_code=404, detail="Room not found")

    if user not in room.participants:
        raise HTTPException(status_code=403, detail="Not a participant in this room")

    # CHECK FILE UPLOAD PERMISSION AND SIZE
    from app.services.subscription_service import can_upload_file

    # Read file to get size
    contents = await file.read()
    file_size_bytes = len(contents)

    upload_check = can_upload_file(subscription, file_size_bytes)
    if not upload_check["can_upload"]:
        raise HTTPException(
            status_code=402,
            detail={
                "error": upload_check["reason"],
                "message": upload_check["message"],
                "limit_mb": upload_check.get("limit_mb", 0),
                "file_size_mb": upload_check.get("file_size_mb", 0),
                "upgrade_url": "/subscription"
            }
        )

    # Upload to S3
    from app.services.s3_service import upload_attachment

    file_url = upload_attachment(
        file_data=contents,
        filename=file.filename,
        room_id=room_id,
        content_type=file.content_type
    )

    # ... rest of existing code (image analysis, turn creation, etc.)
```

### 3. Professional Report Counter

**File:** `backend/app/services/subscription_service.py`

Add functions:

```python
def can_generate_report(db: Session, subscription: Subscription) -> dict:
    """Check if user can generate a professional report"""
    reset_monthly_counters_if_needed(db, subscription)

    # Only PRO tier gets reports
    if subscription.tier != SubscriptionTier.PRO:
        return {
            "can_generate": False,
            "reason": "NOT_PRO_TIER",
            "message": "Professional evaluation reports are a Pro-tier feature. Upgrade to Pro to get 3 reports per month.",
            "reports_used": 0,
            "reports_limit": 0
        }

    # Check monthly limit (3 reports for PRO)
    if subscription.reports_generated_this_month >= subscription.reports_limit_per_month:
        return {
            "can_generate": False,
            "reason": "MONTHLY_LIMIT_REACHED",
            "message": f"You've used all {subscription.reports_limit_per_month} monthly reports. Purchase an additional report for ¬£4.99.",
            "reports_used": subscription.reports_generated_this_month,
            "reports_limit": subscription.reports_limit_per_month,
            "extra_report_price": 4.99
        }

    return {
        "can_generate": True,
        "reason": None,
        "message": None,
        "reports_used": subscription.reports_generated_this_month,
        "reports_limit": subscription.reports_limit_per_month
    }

def increment_report_counter(db: Session, subscription: Subscription) -> None:
    """Increment the reports generated counter for this month"""
    reset_monthly_counters_if_needed(db, subscription)
    subscription.reports_generated_this_month += 1
    db.commit()
```

**File:** `backend/app/routes/rooms.py`

Update report generation endpoint (around line 2638):

```python
@router.post("/{room_id}/generate-report")
async def generate_professional_report(
    room_id: int,
    user: User = Depends(get_current_user),
    subscription: Subscription = Depends(get_current_subscription),
    db: Session = Depends(get_db)
):
    import logging
    logger = logging.getLogger(__name__)

    # Verify room exists and user is participant
    room = db.query(Room).filter(Room.id == room_id).first()
    if not room:
        raise HTTPException(status_code=404, detail="Room not found")

    if user not in room.participants:
        raise HTTPException(status_code=403, detail="Not authorized to generate report for this room")

    # Must be resolved room
    if room.phase != "resolved":
        raise HTTPException(status_code=400, detail="Report can only be generated for resolved rooms")

    # CHECK REPORT GENERATION LIMIT
    from app.services.subscription_service import can_generate_report, increment_report_counter

    report_check = can_generate_report(db, subscription)
    if not report_check["can_generate"]:
        raise HTTPException(
            status_code=402,
            detail={
                "error": report_check["reason"],
                "message": report_check["message"],
                "reports_used": report_check.get("reports_used", 0),
                "reports_limit": report_check.get("reports_limit", 0),
                "extra_report_price": report_check.get("extra_report_price"),
                "upgrade_url": "/subscription"
            }
        )

    # If report already exists, return it (don't count against limit)
    if room.professional_report_url:
        return {
            "success": True,
            "report_url": room.professional_report_url,
            "message": "Report already generated",
            "cached": True
        }

    # ... existing report generation code ...

    # After successful generation, increment counter
    increment_report_counter(db, subscription)

    return {
        "success": True,
        "report_url": room.professional_report_url,
        "message": "Report generated successfully",
        "cost_usd": cost_usd,
        "input_tokens": input_tokens,
        "output_tokens": output_tokens,
        "reports_used": subscription.reports_generated_this_month,
        "reports_remaining": subscription.reports_limit_per_month - subscription.reports_generated_this_month
    }
```

### 4. Update Subscription Creation

**File:** `backend/app/services/subscription_service.py`

Update the `get_or_create_subscription` function:

```python
def get_or_create_subscription(db: Session, user_id: int) -> Subscription:
    """Get or create subscription for user with proper initialization"""
    subscription = db.query(Subscription).filter(Subscription.user_id == user_id).first()

    if not subscription:
        now = datetime.utcnow()
        month_start = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)

        subscription = Subscription(
            user_id=user_id,
            tier=SubscriptionTier.FREE,
            status=SubscriptionStatus.TRIAL,
            start_date=now,
            voice_conversations_used=0,
            voice_conversations_limit=10,  # FREE tier gets 10/month
            rooms_created_this_month=0,
            month_reset_date=month_start,
            reports_generated_this_month=0,
            reports_limit_per_month=0  # FREE tier gets no reports
        )
        db.add(subscription)
        db.commit()
        db.refresh(subscription)

    return subscription
```

### 5. Update Webhook Handler for Tier Changes

**File:** `backend/app/routes/subscriptions.py`

Update webhook handler to set report limits (around line where tier is updated):

```python
def handle_subscription_updated(subscription_data: dict, db: Session):
    """Handle subscription.updated webhook"""
    stripe_subscription_id = subscription_data.get('id')

    subscription = db.query(Subscription).filter(
        Subscription.stripe_subscription_id == stripe_subscription_id
    ).first()

    if not subscription:
        logger.warning(f"Subscription {stripe_subscription_id} not found in database")
        return

    # Update tier based on price_id
    price_id = subscription_data['items']['data'][0]['price']['id']

    # Determine new tier
    if price_id in [settings.STRIPE_PRICE_PLUS_MONTHLY, settings.STRIPE_PRICE_PLUS_YEARLY]:
        new_tier = SubscriptionTier.PLUS
        voice_limit = -1  # Unlimited
        reports_limit = 0  # No reports
    elif price_id in [settings.STRIPE_PRICE_PRO_MONTHLY, settings.STRIPE_PRICE_PRO_YEARLY]:
        new_tier = SubscriptionTier.PRO
        voice_limit = -1  # Unlimited
        reports_limit = 3  # 3 reports per month
    else:
        new_tier = SubscriptionTier.FREE
        voice_limit = 10
        reports_limit = 0

    subscription.tier = new_tier
    subscription.status = SubscriptionStatus.ACTIVE
    subscription.stripe_price_id = price_id
    subscription.voice_conversations_limit = voice_limit
    subscription.reports_limit_per_month = reports_limit

    db.commit()
```

---

## Frontend Implementation

### 1. Room Creation Limit UI

**File:** `frontend/src/pages/CreateRoom.jsx`

Update the `handleNext` function to handle room limit errors:

```javascript
const handleNext = () => {
  if (step === 1) {
    if (!title.trim()) {
      alert("Please add a conversation title");
      return;
    }
    if (!category) {
      alert("Please choose a topic category");
      return;
    }

    setStep(2);
  } else {
    handleCreate();
  }
};

const handleCreate = async () => {
  if (!initialIssue.trim()) {
    alert("Please describe what you'd like to discuss");
    return;
  }

  setLoading(true);
  try {
    const room = await apiRequest("/rooms/", "POST", {
      title,
      category: category.toLowerCase()
    }, token);

    sessionStorage.setItem(`room_${room.id}_initial`, initialIssue);
    navigate(`/rooms/${room.id}/coaching`);
  } catch (error) {
    // Check if it's a 402 Payment Required error
    if (error.status === 402 || error.statusCode === 402) {
      const errorData = typeof error === 'string' ? JSON.parse(error) : error;

      if (errorData.error === "FREE_TIER_ACTIVE_ROOM_LIMIT") {
        // Show specific message for room limit
        const proceed = window.confirm(
          `${errorData.message}\n\nWould you like to view your subscription options?`
        );

        if (proceed) {
          navigate('/subscription');
        }
      } else {
        // Generic upgrade prompt
        alert(errorData.message || "This feature requires a subscription upgrade.");
      }
    } else {
      alert("Error creating room: " + (error.message || "Unknown error"));
    }
  } finally {
    setLoading(false);
  }
};
```

### 2. File Upload Size Limit UI

**File:** `frontend/src/pages/MainRoom.jsx`

Update file upload handler (around line 906):

```javascript
const handleFileUpload = async (event) => {
  const file = event.target.files[0];
  if (!file) return;

  // Check file size before upload
  const fileSizeMB = file.size / (1024 * 1024);

  setUploading(true);
  try {
    const formData = new FormData();
    formData.append('file', file);

    const response = await apiRequest(
      `/rooms/${roomId}/main-room/upload-file`,
      'POST',
      formData,
      token,
      { 'Content-Type': 'multipart/form-data' }
    );

    // Refresh messages to show new attachment
    fetchMessages();

    // Clear file input
    event.target.value = '';
  } catch (error) {
    console.error('File upload error:', error);

    // Check if it's a 402 Payment Required error
    if (error.status === 402 || error.statusCode === 402) {
      const errorData = typeof error === 'string' ? JSON.parse(error) : error;

      if (errorData.error === "FREE_TIER_NO_FILES") {
        const proceed = window.confirm(
          `${errorData.message}\n\nWould you like to upgrade your subscription?`
        );

        if (proceed) {
          navigate('/subscription');
        }
      } else if (errorData.error === "FILE_TOO_LARGE") {
        alert(
          `File is too large!\n\n` +
          `Your file: ${errorData.file_size_mb?.toFixed(1)}MB\n` +
          `Your limit: ${errorData.limit_mb}MB\n\n` +
          `${errorData.message}`
        );
      } else {
        alert(errorData.message || "File upload failed");
      }
    } else {
      alert('Failed to upload file: ' + (error.message || 'Unknown error'));
    }
  } finally {
    setUploading(false);
  }
};
```

### 3. Professional Report Limit UI

**File:** `frontend/src/pages/ResolutionComplete.jsx`

Update the report generation handler:

```javascript
const generateReport = async () => {
  setGeneratingReport(true);
  try {
    const response = await apiRequest(
      `/rooms/${roomId}/generate-report`,
      'POST',
      null,
      token
    );

    if (response.success) {
      setReportUrl(response.report_url);

      // Show remaining reports if PRO tier
      if (response.reports_remaining !== undefined) {
        alert(
          `Report generated successfully!\n\n` +
          `Reports remaining this month: ${response.reports_remaining}/${response.reports_limit}`
        );
      }
    }
  } catch (error) {
    console.error('Report generation error:', error);

    // Check if it's a 402 Payment Required error
    if (error.status === 402 || error.statusCode === 402) {
      const errorData = typeof error === 'string' ? JSON.parse(error) : error;

      if (errorData.error === "NOT_PRO_TIER") {
        const proceed = window.confirm(
          `${errorData.message}\n\nWould you like to upgrade to Pro?`
        );

        if (proceed) {
          navigate('/subscription');
        }
      } else if (errorData.error === "MONTHLY_LIMIT_REACHED") {
        // Future: Show option to purchase additional report for ¬£4.99
        alert(
          `${errorData.message}\n\n` +
          `Used: ${errorData.reports_used}/${errorData.reports_limit}\n\n` +
          `One-time report purchases coming soon!`
        );
      } else {
        alert(errorData.message || "Report generation failed");
      }
    } else {
      alert('Failed to generate report. Please try again.');
    }
  } finally {
    setGeneratingReport(false);
  }
};
```

### 4. Subscription Status Display

**File:** `frontend/src/pages/Profile.jsx` (or create a new UsageStats component)

Add a usage stats section:

```javascript
const [subscriptionStatus, setSubscriptionStatus] = useState(null);

useEffect(() => {
  const fetchSubscriptionStatus = async () => {
    if (token) {
      try {
        const status = await apiRequest('/subscriptions/status', 'GET', null, token);
        setSubscriptionStatus(status);
      } catch (error) {
        console.error('Failed to fetch subscription status:', error);
      }
    }
  };

  fetchSubscriptionStatus();
}, [token]);

// In the render:
{subscriptionStatus && (
  <div style={styles.usageStats}>
    <h3>Your Usage This Month</h3>

    {subscriptionStatus.tier === 'FREE' && (
      <>
        <div style={styles.stat}>
          <span>Voice Recordings:</span>
          <span>{subscriptionStatus.voice_conversations_used} / {subscriptionStatus.voice_conversations_limit}</span>
        </div>
        <div style={styles.stat}>
          <span>Active Rooms:</span>
          <span>{subscriptionStatus.active_rooms} / 1</span>
        </div>
      </>
    )}

    {subscriptionStatus.tier === 'PRO' && (
      <div style={styles.stat}>
        <span>Professional Reports:</span>
        <span>{subscriptionStatus.reports_used} / {subscriptionStatus.reports_limit}</span>
      </div>
    )}

    {subscriptionStatus.tier !== 'PRO' && (
      <button onClick={() => navigate('/subscription')}>
        Upgrade for More Features
      </button>
    )}
  </div>
)}
```

---

## Stripe Configuration

### Products & Prices Setup

1. **Create Products in Stripe Dashboard:**
   - Product 1: "Meedi8 Plus"
   - Product 2: "Meedi8 Pro"

2. **Create Prices:**
   - Plus Monthly: ¬£9.99/month (recurring)
   - Plus Yearly: ¬£99/year (recurring, save 17%)
   - Pro Monthly: ¬£19.99/month (recurring)
   - Pro Yearly: ¬£199/year (recurring, save 17%)
   - Extra Report: ¬£4.99 (one-time) - **Future implementation**

3. **Update Environment Variables:**

Add to `backend/.env`:
```bash
STRIPE_SECRET_KEY=sk_test_...
STRIPE_PUBLISHABLE_KEY=pk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...

# Price IDs (update these with your actual Stripe price IDs)
STRIPE_PRICE_PLUS_MONTHLY=price_1SPo09HXmcf1Lx99xoAB0lEZ
STRIPE_PRICE_PLUS_YEARLY=price_1SPo3yHXmcf1Lx99XOiPRSv2
STRIPE_PRICE_PRO_MONTHLY=price_1SPo14HXmcf1Lx99PCT2Nxvh
STRIPE_PRICE_PRO_YEARLY=price_1SPo3HHXmcf1Lx99a91O2NNp
```

### Webhook Configuration

1. **In Stripe Dashboard:**
   - Go to Developers ‚Üí Webhooks
   - Add endpoint: `https://meedi8-production.up.railway.app/subscriptions/webhook`
   - Select events:
     - `checkout.session.completed`
     - `customer.subscription.updated`
     - `customer.subscription.deleted`
     - `invoice.payment_succeeded`
     - `invoice.payment_failed`

2. **Copy webhook secret** and add to `.env` as `STRIPE_WEBHOOK_SECRET`

---

## Testing Checklist

### Room Creation Limits

- [ ] FREE user with 0 active rooms can create 1 room
- [ ] FREE user with 1 active room sees error when trying to create 2nd
- [ ] FREE user can create new room after resolving previous one
- [ ] PLUS user can create unlimited active rooms
- [ ] PRO user can create unlimited active rooms
- [ ] Error message shows upgrade prompt
- [ ] Monthly counter resets at month boundary

### File Upload Limits

- [ ] FREE user sees "upgrade required" message when trying to upload
- [ ] PLUS user can upload files up to 10MB
- [ ] PLUS user sees error for files >10MB with upgrade prompt
- [ ] PRO user can upload files up to 50MB
- [ ] PRO user sees error for files >50MB
- [ ] File size is calculated correctly (MB)

### Professional Reports

- [ ] FREE user sees "upgrade to PRO" message
- [ ] PLUS user sees "upgrade to PRO" message
- [ ] PRO user can generate 3 reports per month
- [ ] PRO user sees limit reached message after 3 reports
- [ ] Report counter resets at month boundary
- [ ] Cached reports don't count toward limit

### Voice Recording Limits

- [ ] FREE user starts with 10 voice recordings/month
- [ ] FREE user counter decrements correctly
- [ ] FREE user sees error at 0 remaining
- [ ] PLUS user has unlimited voice recordings
- [ ] PRO user has unlimited voice recordings
- [ ] Voice counter resets at month boundary

### Subscription Flow

- [ ] User can upgrade from FREE to PLUS (monthly)
- [ ] User can upgrade from FREE to PLUS (yearly)
- [ ] User can upgrade from FREE to PRO (monthly)
- [ ] User can upgrade from FREE to PRO (yearly)
- [ ] User can upgrade from PLUS to PRO
- [ ] Webhook correctly updates tier in database
- [ ] Limits change immediately after upgrade
- [ ] User can cancel subscription via Customer Portal
- [ ] Canceled subscription maintains access until period end

### Edge Cases

- [ ] Month boundary reset works correctly (test with date mocking)
- [ ] Multiple rapid room creations don't bypass limit
- [ ] Webhook failures are logged and retried
- [ ] Stripe customer creation is idempotent
- [ ] Subscription status endpoint returns correct data

---

## Deployment Steps

### Phase 1: Database Migration

```bash
# 1. Create migration
cd backend
alembic revision --autogenerate -m "Add usage counters to subscriptions"

# 2. Review generated migration file
# 3. Test migration locally
alembic upgrade head

# 4. Deploy to Railway (automatic on git push)
git add .
git commit -m "Add subscription usage counters and paywalls"
git push origin main
```

### Phase 2: Monitor Deployment

1. Check Railway logs for migration success
2. Verify webhook endpoint is accessible: `curl https://meedi8-production.up.railway.app/subscriptions/webhook`
3. Test subscription status endpoint: `curl https://meedi8-production.up.railway.app/subscriptions/status` (with auth)

### Phase 3: Test in Production

1. Create test account with FREE tier
2. Attempt to create 2 rooms (should be blocked)
3. Upgrade to PLUS via Stripe Checkout (use test card: 4242 4242 4242 4242)
4. Verify limits are updated
5. Test file upload with different sizes
6. Test report generation (if PRO)

---

## Future Enhancements

### One-Time Report Purchases

**Stripe Integration:**
```python
# Create one-time payment session for extra report
@router.post("/subscriptions/buy-extra-report")
async def buy_extra_report(
    room_id: int,
    user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    # Create Stripe Checkout session for ¬£4.99 one-time payment
    session = stripe.checkout.Session.create(
        customer=user.stripe_customer_id,
        payment_method_types=['card'],
        line_items=[{
            'price': settings.STRIPE_PRICE_EXTRA_REPORT,
            'quantity': 1,
        }],
        mode='payment',
        success_url=f'{settings.FRONTEND_URL}/rooms/{room_id}/report-purchased?session_id={{CHECKOUT_SESSION_ID}}',
        cancel_url=f'{settings.FRONTEND_URL}/rooms/{room_id}/resolution',
        metadata={
            'room_id': room_id,
            'user_id': user.id,
            'product': 'extra_report'
        }
    )

    return {'checkout_url': session.url}
```

### Admin Dashboard

**Metrics to Track:**
- Monthly Recurring Revenue (MRR)
- Total active subscribers by tier
- Churn rate
- Average revenue per user (ARPU)
- Conversion rate (FREE ‚Üí PLUS ‚Üí PRO)
- Feature usage by tier

**Endpoint:**
```python
@router.get("/admin/subscription-metrics", dependencies=[Depends(require_admin)])
async def get_subscription_metrics(db: Session = Depends(get_db)):
    # Calculate MRR, subscriber counts, etc.
    # Return JSON with metrics for dashboard
    pass
```

### Usage Notifications

**Email Alerts:**
- 80% of voice recordings used: "You've used 8 of 10 voice recordings this month"
- 100% of voice recordings used: "You've reached your voice recording limit. Upgrade to continue"
- Room limit reached: "You have 1 active mediation. Resolve it or upgrade for unlimited"

---

## Cost Analysis

### FREE Tier Costs

**Assumptions:**
- Average mediation: 20 AI messages (10 user, 10 AI)
- Average tokens per message: 500 input, 800 output
- Voice recordings: 10 √ó 2 minutes = 20 minutes

**Per-User Costs:**
- AI (Claude): 20 messages √ó (500 √ó $0.003 + 800 √ó $0.015) / 1000 = $0.27
- Voice (Whisper): 20 minutes √ó $0.006 = $0.12
- **Total: ~$0.40 per FREE user per month**

**Break-even:**
- Need to convert 1 in 25 FREE users to PLUS (¬£9.99) to break even
- Or 1 in 50 to PRO (¬£19.99)

### PLUS Tier Profitability

**Revenue:** ¬£9.99/month = ¬£119.88/year
**Costs (assuming 5 mediations/month):**
- AI: 5 √ó $0.27 = $1.35
- Voice: Unlimited, estimate 50 minutes = $0.30
- Storage: S3 ~$0.10
- **Total: ~$1.75/month = $21/year**

**Profit Margin:** ~82%

### PRO Tier Profitability

**Revenue:** ¬£19.99/month = ¬£239.88/year
**Costs (assuming 10 mediations/month + 3 reports):**
- AI: 10 √ó $0.27 = $2.70
- Voice: Unlimited, estimate 100 minutes = $0.60
- Reports: 3 √ó $0.05 = $0.15
- Storage: S3 ~$0.20
- **Total: ~$3.65/month = $43.80/year**

**Profit Margin:** ~82%

---

## Summary

This guide provides a complete implementation plan for Meedi8's paywall system with:

‚úÖ **Room creation limits** - 1 active room for FREE, unlimited for PLUS/PRO
‚úÖ **Voice recording limits** - 10/month for FREE (already working), unlimited for paid
‚úÖ **File upload limits** - No files for FREE, 10MB for PLUS, 50MB for PRO
‚úÖ **Professional report limits** - 3/month for PRO, with option to purchase extras
‚úÖ **Monthly counter resets** - Automatic reset at month boundary
‚úÖ **Stripe integration** - Complete webhook handling and tier management
‚úÖ **User experience** - Clear error messages with upgrade prompts
‚úÖ **Cost tracking** - API usage monitoring for profitability analysis

**Implementation Timeline:**
- Week 1: Room limits + File size limits + Migration
- Week 2: Report counter + Testing
- Week 3: Polish + Deploy

**Priority Order:**
1. Room creation limits (highest conversion impact)
2. File upload size validation (tier differentiation)
3. Professional report counter (PRO feature enforcement)
4. Transcript UI limits (low priority - users rarely check old transcripts)
